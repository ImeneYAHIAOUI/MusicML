"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MIDIVal = exports.matchesConfig = void 0;
const MIDIValInput_1 = require("./MIDIValInput");
const MIDIValOutput_1 = require("./MIDIValOutput");
const BrowserMIDIAccess_1 = require("./wrappers/access/BrowserMIDIAccess");
const matchesConfig = (input, scheme) => {
    return Object.keys(scheme).reduce((acc, key) => {
        const val = scheme[key];
        if (typeof val === "string") {
            return acc && input[key] === val;
        }
        else {
            return acc && val.test(input[key]);
        }
    }, true);
};
exports.matchesConfig = matchesConfig;
class MIDIVal {
    /**
     * Allows to reconfigure access object to use project in different environment as the default one (browser): See @midival/node, @midival/react-native for more details.
     * @param newAccess Implementation of IMIDIAccess to be used to provide MIDI objects.
     */
    static configureAccessObject(newAccess) {
        this.isSetupComplete = false;
        this.accessObject = newAccess;
    }
    /**
     * Calls callback on every input device that gets connected.
     * @param callback Callback to be registered
     * @param callOnAlreadyConnected If set to true, the function will instantly trigger for all already connected devices. Default to false
     * @returns Promise resolving to unregister callback when finishes.
     */
    static onInputDeviceConnected(callback, callOnAlreadyConnected = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (callOnAlreadyConnected) {
                this.accessObject.inputs.forEach(callback);
            }
            return this.accessObject.onInputConnected(callback);
        });
    }
    /**
     * Listens to all input devices with a certain config (like name or manufacturer). Configuration can be provided as a string or regex. The callback unlike `onInputDeviceConnected` accepts MIDIValInput. `onInputDeviceConnected` is suitable when you want to filter devices yourself, beyond this configuration object so it does not instantiate objects.
     * @param config Configuration object used to match with device connected
     * @param fn Callback on connection. Connection is already wrapped in MIDIValInput object
     * @returns Promise for Unregister Callback
     */
    static onInputDeviceWithConfigConnected(config, fn, callOnAlreadyConnected = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.onInputDeviceConnected((input) => {
                if ((0, exports.matchesConfig)(input, config)) {
                    fn(new MIDIValInput_1.MIDIValInput(input));
                }
            }, callOnAlreadyConnected);
        });
    }
    /**
     * Listens to all output devices with a certain config (like name or manufacturer). Configuration can be provided as a string or regex. The callback unlike `onOutputDeviceConnected` accepts MIDIValOutput. `onOutputDeviceConnected` is suitable when you want to filter devices yourself, beyond this configuration object so it does not instantiate objects.
     * @param config Configuration object used to match with device connected
     * @param fn Callback on connection. Connection is already wrapped in MIDIValOutput object
     * @returns Promise for Unregister Callback
     */
    static onOutputDeviceWithConfigConnected(config, fn, callOnAlreadyConnected = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.onOutputDeviceConnected((output) => {
                if ((0, exports.matchesConfig)(output, config)) {
                    fn(new MIDIValOutput_1.MIDIValOutput(output));
                }
            }, callOnAlreadyConnected);
        });
    }
    /**
     * Calls callback on every output device that gets connected.
     * @param callback Callback to be registered
     * @param callOnAlreadyConnected If set to true, the function will instantly trigger for all already connected devices. Default to false
     * @returns Promise resolving to unregister callback when finishes.
     */
    static onOutputDeviceConnected(callback, callOnAlreadyConnected = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (callOnAlreadyConnected) {
                this.accessObject.outputs.forEach(callback);
            }
            return this.accessObject.onOutputConnected(callback);
        });
    }
    /**
     * Regusters callback on an event of input device being disconnected.
     * @param callback Callback to be called.
     * @returns promise resolving to unregister callback
     */
    static onInputDeviceDisconnected(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accessObject.onInputDisconnected(callback);
        });
    }
    /**
     * Regusters callback on an event of input device being disconnected.
     * @param callback Callback to be called.
     * @returns promise resolving to unregister callback
     */
    static onOutputDeviceDisconnected(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accessObject.onOutputDisconnected(callback);
        });
    }
    /**
     * Creates MIDIValInput instance from implementation of IMIDIInput interface.
     * @param input Implementation of IMIDIInput interface
     * @returns MIDIValInput object
     */
    static fromMIDIInput(input) {
        return new MIDIValInput_1.MIDIValInput(input);
    }
    /**
     * Creates MIDIValOutput instance from implementation of IMIDIOut interface
     * @param output Implementation of IMIDIOutput interface
     * @returns MIDIValOutput object
     */
    static fromMIDIOutput(output) {
        return new MIDIValOutput_1.MIDIValOutput(output);
    }
    /**
     * Connects to MIDI interface and returns implementation of IMIDIAccess
     * @returns Promise resolving to IMIDIAccess
     */
    static connect() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setupDeviceWatchers();
            return this.accessObject;
        });
    }
    static setupDeviceWatchers() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isSetupComplete) {
                return;
            }
            this.isSetupComplete = true;
            if (!this.accessObject) {
                this.accessObject = new BrowserMIDIAccess_1.BrowserMIDIAccess();
            }
            yield this.accessObject.connect();
        });
    }
}
MIDIVal.isSetupComplete = false;
exports.MIDIVal = MIDIVal;
