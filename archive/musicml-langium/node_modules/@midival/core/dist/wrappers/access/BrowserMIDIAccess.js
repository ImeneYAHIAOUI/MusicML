"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserMIDIAccess = void 0;
const BrowserMIDIOutput_1 = require("../outputs/BrowserMIDIOutput");
const BrowserMIDIInput_1 = require("../inputs/BrowserMIDIInput");
const omnibus_1 = require("@hypersphere/omnibus");
class BrowserMIDIAccess {
    constructor() {
        this.bus = new omnibus_1.Omnibus();
    }
    onInputConnected(callback) {
        return this.bus.on("inputConnected", callback);
    }
    onInputDisconnected(callback) {
        return this.bus.on("inputDisconnected", callback);
    }
    onOutputConnected(callback) {
        return this.bus.on("outputConnected", callback);
    }
    onOutputDisconnected(callback) {
        return this.bus.on("outputDisconnected", callback);
    }
    connect(sysex = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!navigator.requestMIDIAccess) {
                throw new Error("requestMIDIAccess not available, make sure you are using MIDI-compatible browser.");
            }
            this.access = yield navigator.requestMIDIAccess({ sysex }); // FIXME: check.
            this.listenOnStateChange();
        });
    }
    get outputs() {
        // FIXME: guard to be called after succesful connect.
        return Array.from(this.access.outputs).map(([, output]) => new BrowserMIDIOutput_1.BrowserMIDIOutput(output));
    }
    get inputs() {
        // FIXME: guard to be called after succesful connect.
        return Array.from(this.access.inputs).map(([, input]) => new BrowserMIDIInput_1.BrowserMIDIInput(input));
    }
    getInputById(inputId) {
        const input = Array.from(this.access.inputs)
            .map(([, input]) => input)
            .find(({ id }) => id === inputId);
        if (!input) {
            throw new Error(`Cannot find input ${inputId}`);
        }
        return new BrowserMIDIInput_1.BrowserMIDIInput(input);
    }
    getOutputById(outputId) {
        const output = Array.from(this.access.outputs)
            .map(([, output]) => output)
            .find(({ id }) => id === outputId);
        if (!output) {
            throw new Error(`Cannot find output ${outputId}`);
        }
        return new BrowserMIDIOutput_1.BrowserMIDIOutput(output);
    }
    listenOnStateChange() {
        this.access.addEventListener("statechange", (e) => {
            if (e.port.type === "input") {
                switch (e.port.state) {
                    case "disconnected":
                        this.bus.trigger("inputDisconnected", new BrowserMIDIInput_1.BrowserMIDIInput(e.port));
                        break;
                    case "connected":
                        this.bus.trigger("inputConnected", new BrowserMIDIInput_1.BrowserMIDIInput(e.port));
                        break;
                }
            }
            else {
                switch (e.port.state) {
                    case "disconnected":
                        this.bus.trigger("outputDisconnected", new BrowserMIDIOutput_1.BrowserMIDIOutput(e.port));
                        break;
                    case "connected":
                        this.bus.trigger("outputConnected", new BrowserMIDIOutput_1.BrowserMIDIOutput(e.port));
                        break;
                }
            }
        });
    }
}
exports.BrowserMIDIAccess = BrowserMIDIAccess;
