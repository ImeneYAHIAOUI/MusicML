"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MIDIValInput = void 0;
const omnibus_1 = require("@hypersphere/omnibus");
const MIDIMessageConvert_1 = require("./utils/MIDIMessageConvert");
const index_1 = require("./index");
const pitchBend_1 = require("./utils/pitchBend");
const midiCommands_1 = require("./utils/midiCommands");
const midiControlChanges_1 = require("./utils/midiControlChanges");
const clock_1 = require("./utils/clock");
const errors_1 = require("./errors");
const messages_1 = require("./types/messages");
const midiRegisteredParameters_1 = require("./utils/midiRegisteredParameters");
const TEMPO_SAMPLES_LIMIT = 20;
const DefaultOptions = {
    computeClockTempo: false,
};
class MIDIValInput {
    constructor(input, options = DefaultOptions) {
        this.rpn = [-1, -1];
        this.omnibus = new omnibus_1.Omnibus();
        this.tempoSamples = [];
        this.registerInput(input);
        this.options = options;
    }
    /**
     * Returns new MIDIValInput object based on the interface id.
     * @param interfaceId id of the interface from the MIDIAcces object.
     * @throws MIDIValError when interface id is not found.
     * @returns Promise resolving to MIDIValInput.
     */
    static fromInterfaceId(interfaceId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const midiAccess = yield this.getMidiAccess();
            const input = midiAccess.inputs.find(({ id }) => id === interfaceId);
            if (!input) {
                throw new errors_1.MIDIValError(`${interfaceId} not found`);
            }
            return new MIDIValInput(input, options);
        });
    }
    /**
     * Finds first interface matching the name
     * @param interfaceName interface Name
     * @param options input configuration options
     * @throws MIDIValError when no interface with that name is found
     * @returns MIDIValInput object
     */
    static fromInterfaceName(interfaceName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const midiAccess = yield this.getMidiAccess();
            const input = midiAccess.inputs.find(({ name }) => name === interfaceName);
            if (!input) {
                throw new errors_1.MIDIValError(`${interfaceName} not found`);
            }
            return new MIDIValInput(input, options);
        });
    }
    static getMidiAccess() {
        return __awaiter(this, void 0, void 0, function* () {
            const midiAccess = yield index_1.MIDIVal.connect();
            return midiAccess;
        });
    }
    /**
     * Current MIDI Clock tempo
     * @throws MIDIValConfigurationError when computeClockTempo is not on.
     * @returns current tempo in BPM.
     */
    get tempo() {
        if (!this.options.computeClockTempo) {
            throw new errors_1.MIDIValConfigurationError("To use MIDIValInput.tempo you need to enable computeClockTempo option.");
        }
        return (0, clock_1.ticksToBPM)(this.tempoSamples);
    }
    registerInput(input) {
        return __awaiter(this, void 0, void 0, function* () {
            this.midiInput = input;
            this.unregisterInput = yield input.onMessage((e) => {
                if (e.data[0] === 0xf0) {
                    // sysex
                    this.omnibus.trigger("sysex", e.data);
                    return;
                }
                if (this.isClockCommand(e)) {
                    return;
                }
                const midiMessage = (0, MIDIMessageConvert_1.toMidiMessage)(e.data);
                switch (midiMessage.command) {
                    case midiCommands_1.MidiCommand.NoteOn:
                        this.omnibus.trigger("noteOn", (0, messages_1.toNoteMessage)(midiMessage));
                        break;
                    case midiCommands_1.MidiCommand.NoteOff:
                        this.omnibus.trigger("noteOff", (0, messages_1.toNoteMessage)(midiMessage));
                        break;
                    case midiCommands_1.MidiCommand.ControlChange:
                        this.omnibus.trigger("controlChange", (0, messages_1.toControlChangeMessage)(midiMessage));
                        break;
                    case midiCommands_1.MidiCommand.ProgramChange:
                        this.omnibus.trigger("programChange", (0, messages_1.toProgramMessage)(midiMessage));
                        break;
                    case midiCommands_1.MidiCommand.PolyKeyPressure:
                        this.omnibus.trigger("polyKeyPressure", midiMessage);
                        break;
                    case midiCommands_1.MidiCommand.PitchBend:
                        this.omnibus.trigger("pitchBend", {
                            channel: midiMessage.channel,
                            value: (0, pitchBend_1.splitValueIntoFraction)([
                                midiMessage.data1,
                                midiMessage.data2,
                            ]),
                        });
                        break;
                    case midiCommands_1.MidiCommand.ChannelPressure:
                        this.omnibus.trigger("channelPressure", midiMessage);
                        break;
                    default:
                        // TODO: Unknown message.
                        console.log("unknown msg", midiMessage);
                        break;
                }
            });
            if (this.options.computeClockTempo) {
                this.onClockPulse(() => {
                    // compute time
                    this.tempoSamples.push(performance.now());
                    if (this.tempoSamples.length > TEMPO_SAMPLES_LIMIT) {
                        this.tempoSamples.shift();
                    }
                });
                const resetSamples = () => {
                    this.tempoSamples = [];
                };
                this.onClockContinue(resetSamples);
                this.onClockStart(resetSamples);
            }
            // RPM
            this.onControlChange(midiControlChanges_1.MidiControlChange.RegisteredParameterNumberMSB, (message) => {
                this.rpn = [message.data2, this.rpn[1]];
            });
            this.onControlChange(midiControlChanges_1.MidiControlChange.RegisteredParameterNumberLSB, (message) => {
                this.rpn = [this.rpn[0], message.data2];
            });
            this.onControlChange(midiControlChanges_1.MidiControlChange.DataEntryMSB, (message) => {
                const key = (0, midiRegisteredParameters_1.toRegisteredParameterKey)(this.rpn);
                this.omnibus.trigger("registeredParameterData", {
                    channel: message.channel,
                    parameter: key,
                    msb: message.data2,
                    lsb: null,
                });
            });
            this.onControlChange(midiControlChanges_1.MidiControlChange.DataEntryLSB, (message) => {
                const key = (0, midiRegisteredParameters_1.toRegisteredParameterKey)(this.rpn);
                this.omnibus.trigger("registeredParameterData", {
                    channel: message.channel,
                    parameter: key,
                    msb: null,
                    lsb: message.data2,
                });
            });
        });
    }
    isClockCommand(e) {
        switch (e.data[0]) {
            case midiCommands_1.MidiCommand.Clock.Pulse:
                this.omnibus.trigger("clockPulse");
                return true;
            case midiCommands_1.MidiCommand.Clock.Start:
                this.omnibus.trigger("clockStart");
                return true;
            case midiCommands_1.MidiCommand.Clock.Continue:
                this.omnibus.trigger("clockContinue");
                return true;
            case midiCommands_1.MidiCommand.Clock.Stop:
                this.omnibus.trigger("clockStop");
                return true;
            default:
                return false;
        }
    }
    onBusKeyValue(event, key, value, callback) {
        return this.omnibus.on(event, (...args) => {
            if (!args.length) {
                return;
            }
            const obj = args[0];
            // FIXME: how to do it so we have multiple args?
            if (obj[key] === value) {
                callback(obj);
            }
        });
    }
    /**
     * Disconnects all listeners.
     */
    disconnect() {
        this.omnibus.offAll();
        if (this.unregisterInput) {
            this.unregisterInput();
        }
    }
    /**
     * Registers new callback on every note on event.
     * @param callback Callback that will get called on each note on event.
     * @returns Callback to unregister.
     */
    onAllNoteOn(callback) {
        return this.omnibus.on("noteOn", callback);
    }
    /**
     * Registers new callback on specific note on event.
     * @param key the key number
     * @param callback Callback that gets called on every note on on this specific key
     * @returns Callback to unregister.
     */
    onNoteOn(key, callback) {
        return this.omnibus.on("noteOn", (midiMessage) => {
            if (midiMessage.note !== key) {
                return;
            }
            return callback(midiMessage);
        });
    }
    /**
     * Registers new callback on all notes off.
     * @param callback Callback that gets called on every note off.
     * @returns Unregister callback
     */
    onAllNoteOff(callback) {
        return this.omnibus.on("noteOff", callback);
    }
    /**
     * Registers new callback on specific note off.
     * @param key key number
     * @param callback Callback that gets called on every note off on this specific key
     * @returns Unregister callback
     */
    onNoteOff(key, callback) {
        return this.onBusKeyValue("noteOff", "note", key, callback);
    }
    /**
     * Registers new callback on pitch bend message
     * @param callback Callback that gets called on every pitch bend message. It gets value of the bend in the range of -1.0 to 1.0 using 16-bit precision (if supported by sending device).
     * @returns Unregister callback.
     */
    onPitchBend(callback) {
        return this.omnibus.on("pitchBend", callback);
    }
    /**
     * Registers callback on every control change message
     * @param callback Callback that will get called on control change.
     * @returns Unregister callback.
     */
    onAllControlChange(callback) {
        return this.omnibus.on("controlChange", callback);
    }
    /**
     * Registers callback on specific control change key.
     * @param channel Control change channel value
     * @param callback Callback to be called
     * @returns Unregister function
     */
    onControlChange(control, callback) {
        if ((0, MIDIMessageConvert_1.isChannelMode)(control)) {
            console.warn("use designated Channel Mode callback instead of onControlChange for " +
                control);
        }
        return this.omnibus.on("controlChange", (m) => {
            if (m.control !== control) {
                return;
            }
            callback(m);
        });
    }
    /**
     * Registers callback to be called on every program change event
     * @param callback Callback to be called
     * @returns Unregister function.
     */
    onAllProgramChange(callback) {
        return this.omnibus.on("programChange", callback);
    }
    /**
     * Registers callback to be called on specific program change
     * @param key Program value for key change
     * @param callback Callback to be called
     * @returns Unregister function
     */
    onProgramChange(program, callback) {
        return this.onBusKeyValue("programChange", "program", program, callback);
    }
    /**
     * Registers callback on all poly key pressure events
     * @param callback Callback to be called
     * @returns Unregister function
     */
    onAllPolyKeyPressure(callback) {
        return this.omnibus.on("polyKeyPressure", callback);
    }
    /**
     * Registers callback on specific poly key pressure event
     * @param key Key for poly key pressure
     * @param callback Callback to be called
     * @returns Unregister function
     */
    onPolyKeyPressure(key, callback) {
        return this.onBusKeyValue("polyKeyPressure", "data1", key, callback);
    }
    /**
     * Registers callback on sysex message
     * @param callback Callback to be called
     * @returns Unregister callback
     */
    onSysex(callback) {
        return this.omnibus.on("sysex", callback);
    }
    /**
     * Registers callback on all sounds off event
     * @param callback Callback to be called
     * @returns Unregister callback
     */
    onAllSoundsOff(callback) {
        return this.onBusKeyValue("controlChange", "control", midiControlChanges_1.MidiControlChange.AllSoundsOff, callback);
    }
    /**
     * Registers callback on reset all controllers event
     * @param callback Callback to be called
     * @returns Unregister callback
     */
    onResetAllControllers(callback) {
        return this.onBusKeyValue("controlChange", "control", midiControlChanges_1.MidiControlChange.ResetAllControllers, callback);
    }
    /**
     * Registers callback on local control change event
     * @param callback Callback to be called: first argument to the callback is a boolean representing if the local control was set on or off
     * @returns Unregister event
     */
    onLocalControlChange(callback) {
        return this.onBusKeyValue("controlChange", "control", midiControlChanges_1.MidiControlChange.LocalControlOnOff, (m) => {
            callback(m.data2 === 127, m);
        });
    }
    /**
     * Registers callback on all notes off
     * @param callback Callback to be called
     * @returns Unregister callback
     */
    onAllNotesOff(callback) {
        return this.onBusKeyValue("controlChange", "control", midiControlChanges_1.MidiControlChange.AllNotesOff, callback);
    }
    onChannelPressure(callback) {
        return this.omnibus.on("channelPressure", callback);
    }
    onOmniModeOff(callback) {
        return this.onBusKeyValue("controlChange", "control", midiControlChanges_1.MidiControlChange.OmniModeOff, callback);
    }
    onOmniModeOn(callback) {
        return this.onBusKeyValue("controlChange", "control", midiControlChanges_1.MidiControlChange.OmniModeOn, callback);
    }
    onMonoModeOn(callback) {
        return this.onBusKeyValue("controlChange", "control", midiControlChanges_1.MidiControlChange.MonoModeOn, callback);
    }
    onPolyModeOn(callback) {
        return this.onBusKeyValue("controlChange", "control", midiControlChanges_1.MidiControlChange.PolyModeOn, callback);
    }
    onClockPulse(callback) {
        return this.omnibus.on("clockPulse", callback);
    }
    onClockStart(callback) {
        return this.omnibus.on("clockStart", callback);
    }
    onClockStop(callback) {
        return this.omnibus.on("clockStop", callback);
    }
    onClockContinue(callback) {
        return this.omnibus.on("clockContinue", callback);
    }
    // RPN
    onMpeConfiguration(callback) {
        return this.onBusKeyValue("registeredParameterData", "parameter", "MPE_CONFIGURATION_MESSAGE", callback);
    }
    onPitchBendSensitivity(callback) {
        return this.onBusKeyValue("registeredParameterData", "parameter", "PITCH_BEND_SENSITIVITY", callback);
    }
    onChannelFineTuning(callback) {
        return this.onBusKeyValue("registeredParameterData", "parameter", "CHANNEL_FINE_TUNING", callback);
    }
    onChannelCoarseTuning(callback) {
        return this.onBusKeyValue("registeredParameterData", "parameter", "CHANNEL_COARSE_TUNING", callback);
    }
    onTuningProgramChange(callback) {
        return this.onBusKeyValue("registeredParameterData", "parameter", "TUNING_PROGRAM_CHANGE", callback);
    }
    onTuningBankChange(callback) {
        return this.onBusKeyValue("registeredParameterData", "parameter", "TUNING_BANK_SELECT", callback);
    }
    onModulationDepthChange(callback) {
        return this.onBusKeyValue("registeredParameterData", "parameter", "MODULATION_DEPTH_CHANGE", callback);
    }
}
exports.MIDIValInput = MIDIValInput;
